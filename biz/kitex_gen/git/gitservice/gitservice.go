// Code generated by Kitex v0.15.2. DO NOT EDIT.

package gitservice

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
	git "github.com/yi-nology/git-manage-service/biz/kitex_gen/git"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"ListRepos": kitex.NewMethodInfo(
		listReposHandler,
		newListReposArgs,
		newListReposResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetRepo": kitex.NewMethodInfo(
		getRepoHandler,
		newGetRepoArgs,
		newGetRepoResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ListBranches": kitex.NewMethodInfo(
		listBranchesHandler,
		newListBranchesArgs,
		newListBranchesResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CreateBranch": kitex.NewMethodInfo(
		createBranchHandler,
		newCreateBranchArgs,
		newCreateBranchResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeleteBranch": kitex.NewMethodInfo(
		deleteBranchHandler,
		newDeleteBranchArgs,
		newDeleteBranchResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	gitServiceServiceInfo                = NewServiceInfo()
	gitServiceServiceInfoForClient       = NewServiceInfoForClient()
	gitServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return gitServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return gitServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return gitServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "GitService"
	handlerType := (*git.GitService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "git",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.15.2",
		Extra:           extra,
	}
	return svcInfo
}

func listReposHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(git.ListReposRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(git.GitService).ListRepos(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ListReposArgs:
		success, err := handler.(git.GitService).ListRepos(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListReposResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newListReposArgs() interface{} {
	return &ListReposArgs{}
}

func newListReposResult() interface{} {
	return &ListReposResult{}
}

type ListReposArgs struct {
	Req *git.ListReposRequest
}

func (p *ListReposArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ListReposArgs) Unmarshal(in []byte) error {
	msg := new(git.ListReposRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListReposArgs_Req_DEFAULT *git.ListReposRequest

func (p *ListReposArgs) GetReq() *git.ListReposRequest {
	if !p.IsSetReq() {
		return ListReposArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListReposArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListReposArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListReposResult struct {
	Success *git.ListReposResponse
}

var ListReposResult_Success_DEFAULT *git.ListReposResponse

func (p *ListReposResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ListReposResult) Unmarshal(in []byte) error {
	msg := new(git.ListReposResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListReposResult) GetSuccess() *git.ListReposResponse {
	if !p.IsSetSuccess() {
		return ListReposResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListReposResult) SetSuccess(x interface{}) {
	p.Success = x.(*git.ListReposResponse)
}

func (p *ListReposResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListReposResult) GetResult() interface{} {
	return p.Success
}

func getRepoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(git.GetRepoRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(git.GitService).GetRepo(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetRepoArgs:
		success, err := handler.(git.GitService).GetRepo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetRepoResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetRepoArgs() interface{} {
	return &GetRepoArgs{}
}

func newGetRepoResult() interface{} {
	return &GetRepoResult{}
}

type GetRepoArgs struct {
	Req *git.GetRepoRequest
}

func (p *GetRepoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetRepoArgs) Unmarshal(in []byte) error {
	msg := new(git.GetRepoRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetRepoArgs_Req_DEFAULT *git.GetRepoRequest

func (p *GetRepoArgs) GetReq() *git.GetRepoRequest {
	if !p.IsSetReq() {
		return GetRepoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetRepoArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetRepoArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetRepoResult struct {
	Success *git.GetRepoResponse
}

var GetRepoResult_Success_DEFAULT *git.GetRepoResponse

func (p *GetRepoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetRepoResult) Unmarshal(in []byte) error {
	msg := new(git.GetRepoResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetRepoResult) GetSuccess() *git.GetRepoResponse {
	if !p.IsSetSuccess() {
		return GetRepoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetRepoResult) SetSuccess(x interface{}) {
	p.Success = x.(*git.GetRepoResponse)
}

func (p *GetRepoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRepoResult) GetResult() interface{} {
	return p.Success
}

func listBranchesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(git.ListBranchesRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(git.GitService).ListBranches(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ListBranchesArgs:
		success, err := handler.(git.GitService).ListBranches(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListBranchesResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newListBranchesArgs() interface{} {
	return &ListBranchesArgs{}
}

func newListBranchesResult() interface{} {
	return &ListBranchesResult{}
}

type ListBranchesArgs struct {
	Req *git.ListBranchesRequest
}

func (p *ListBranchesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ListBranchesArgs) Unmarshal(in []byte) error {
	msg := new(git.ListBranchesRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListBranchesArgs_Req_DEFAULT *git.ListBranchesRequest

func (p *ListBranchesArgs) GetReq() *git.ListBranchesRequest {
	if !p.IsSetReq() {
		return ListBranchesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListBranchesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListBranchesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListBranchesResult struct {
	Success *git.ListBranchesResponse
}

var ListBranchesResult_Success_DEFAULT *git.ListBranchesResponse

func (p *ListBranchesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ListBranchesResult) Unmarshal(in []byte) error {
	msg := new(git.ListBranchesResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListBranchesResult) GetSuccess() *git.ListBranchesResponse {
	if !p.IsSetSuccess() {
		return ListBranchesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListBranchesResult) SetSuccess(x interface{}) {
	p.Success = x.(*git.ListBranchesResponse)
}

func (p *ListBranchesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListBranchesResult) GetResult() interface{} {
	return p.Success
}

func createBranchHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(git.CreateBranchRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(git.GitService).CreateBranch(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateBranchArgs:
		success, err := handler.(git.GitService).CreateBranch(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateBranchResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreateBranchArgs() interface{} {
	return &CreateBranchArgs{}
}

func newCreateBranchResult() interface{} {
	return &CreateBranchResult{}
}

type CreateBranchArgs struct {
	Req *git.CreateBranchRequest
}

func (p *CreateBranchArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateBranchArgs) Unmarshal(in []byte) error {
	msg := new(git.CreateBranchRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateBranchArgs_Req_DEFAULT *git.CreateBranchRequest

func (p *CreateBranchArgs) GetReq() *git.CreateBranchRequest {
	if !p.IsSetReq() {
		return CreateBranchArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateBranchArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateBranchArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateBranchResult struct {
	Success *git.CreateBranchResponse
}

var CreateBranchResult_Success_DEFAULT *git.CreateBranchResponse

func (p *CreateBranchResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateBranchResult) Unmarshal(in []byte) error {
	msg := new(git.CreateBranchResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateBranchResult) GetSuccess() *git.CreateBranchResponse {
	if !p.IsSetSuccess() {
		return CreateBranchResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateBranchResult) SetSuccess(x interface{}) {
	p.Success = x.(*git.CreateBranchResponse)
}

func (p *CreateBranchResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateBranchResult) GetResult() interface{} {
	return p.Success
}

func deleteBranchHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(git.DeleteBranchRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(git.GitService).DeleteBranch(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeleteBranchArgs:
		success, err := handler.(git.GitService).DeleteBranch(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteBranchResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeleteBranchArgs() interface{} {
	return &DeleteBranchArgs{}
}

func newDeleteBranchResult() interface{} {
	return &DeleteBranchResult{}
}

type DeleteBranchArgs struct {
	Req *git.DeleteBranchRequest
}

func (p *DeleteBranchArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteBranchArgs) Unmarshal(in []byte) error {
	msg := new(git.DeleteBranchRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteBranchArgs_Req_DEFAULT *git.DeleteBranchRequest

func (p *DeleteBranchArgs) GetReq() *git.DeleteBranchRequest {
	if !p.IsSetReq() {
		return DeleteBranchArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteBranchArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteBranchArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteBranchResult struct {
	Success *git.DeleteBranchResponse
}

var DeleteBranchResult_Success_DEFAULT *git.DeleteBranchResponse

func (p *DeleteBranchResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteBranchResult) Unmarshal(in []byte) error {
	msg := new(git.DeleteBranchResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteBranchResult) GetSuccess() *git.DeleteBranchResponse {
	if !p.IsSetSuccess() {
		return DeleteBranchResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteBranchResult) SetSuccess(x interface{}) {
	p.Success = x.(*git.DeleteBranchResponse)
}

func (p *DeleteBranchResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteBranchResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) ListRepos(ctx context.Context, Req *git.ListReposRequest) (r *git.ListReposResponse, err error) {
	var _args ListReposArgs
	_args.Req = Req
	var _result ListReposResult
	if err = p.c.Call(ctx, "ListRepos", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetRepo(ctx context.Context, Req *git.GetRepoRequest) (r *git.GetRepoResponse, err error) {
	var _args GetRepoArgs
	_args.Req = Req
	var _result GetRepoResult
	if err = p.c.Call(ctx, "GetRepo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListBranches(ctx context.Context, Req *git.ListBranchesRequest) (r *git.ListBranchesResponse, err error) {
	var _args ListBranchesArgs
	_args.Req = Req
	var _result ListBranchesResult
	if err = p.c.Call(ctx, "ListBranches", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateBranch(ctx context.Context, Req *git.CreateBranchRequest) (r *git.CreateBranchResponse, err error) {
	var _args CreateBranchArgs
	_args.Req = Req
	var _result CreateBranchResult
	if err = p.c.Call(ctx, "CreateBranch", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteBranch(ctx context.Context, Req *git.DeleteBranchRequest) (r *git.DeleteBranchResponse, err error) {
	var _args DeleteBranchArgs
	_args.Req = Req
	var _result DeleteBranchResult
	if err = p.c.Call(ctx, "DeleteBranch", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
