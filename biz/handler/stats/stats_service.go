// Code generated by hertz generator.

package stats

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/yi-nology/git-manage-service/biz/dal/db"
	"github.com/yi-nology/git-manage-service/biz/model/api"
	"github.com/yi-nology/git-manage-service/biz/service/git"
	"github.com/yi-nology/git-manage-service/biz/service/stats"
	"github.com/yi-nology/git-manage-service/pkg/response"
)

// ListBranches .
// @router /api/v1/stats/branches [GET]
func ListBranches(ctx context.Context, c *app.RequestContext) {
	repoKey := c.Query("repo_key")
	if repoKey == "" {
		response.BadRequest(c, "repo_key is required")
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(repoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	branches, err := git.NewGitService().GetBranches(repo.Path)
	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	response.Success(c, branches)
}

// ListAuthors .
// @router /api/v1/stats/authors [GET]
func ListAuthors(ctx context.Context, c *app.RequestContext) {
	repoKey := c.Query("repo_key")
	if repoKey == "" {
		response.BadRequest(c, "repo_key is required")
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(repoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	authors, err := git.NewGitService().GetAuthors(repo.Path)
	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	response.Success(c, authors)
}

// ListCommits .
// @router /api/v1/stats/commits [GET]
func ListCommits(ctx context.Context, c *app.RequestContext) {
	repoKey := c.Query("repo_key")
	branch := c.Query("branch")
	since := c.Query("since")
	until := c.Query("until")

	if repoKey == "" {
		response.BadRequest(c, "repo_key is required")
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(repoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	raw, err := git.NewGitService().GetCommits(repo.Path, branch, since, until)
	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	commits := stats.StatsSvc.ParseCommits(raw)
	response.Success(c, commits)
}

// GetStats .
// @router /api/v1/stats/analyze [GET]
func GetStats(ctx context.Context, c *app.RequestContext) {
	repoKey := c.Query("repo_key")
	branch := c.Query("branch")
	since := c.Query("since")
	until := c.Query("until")

	if repoKey == "" {
		response.BadRequest(c, "repo_key is required")
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(repoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	statsData, status, err, progress := stats.StatsSvc.GetStats(repo.Path, branch, since, until)

	if status == stats.StatusProcessing {
		response.Accepted(c, "Statistics are being calculated in the background. Please try again later.", map[string]string{
			"status":   "processing",
			"progress": progress,
		})
		return
	}

	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	// Filter by author if requested
	author := c.Query("author")
	if author != "" {
		filtered := []*api.AuthorStat{}
		for _, a := range statsData.Authors {
			if a.Name == author || a.Email == author {
				filtered = append(filtered, a)
			}
		}
		statsData.Authors = filtered
		total := 0
		for _, a := range filtered {
			total += a.TotalLines
		}
		statsData.TotalLines = total
	}

	response.Success(c, statsData)
}

// ExportCSV .
// @router /api/v1/stats/export/csv [GET]
func ExportCSV(ctx context.Context, c *app.RequestContext) {
	repoKey := c.Query("repo_key")
	branch := c.Query("branch")
	since := c.Query("since")
	until := c.Query("until")

	if repoKey == "" {
		c.JSON(consts.StatusBadRequest, map[string]string{"error": "repo_key is required"})
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(repoKey)
	if err != nil {
		c.JSON(consts.StatusNotFound, map[string]string{"error": "repo not found"})
		return
	}

	statsData, status, err, _ := stats.StatsSvc.GetStats(repo.Path, branch, since, until)
	if status == stats.StatusProcessing {
		response.Accepted(c, "Stats are being calculated, please try again later", nil)
		return
	}
	if err != nil {
		c.JSON(consts.StatusInternalServerError, map[string]string{"error": err.Error()})
		return
	}

	c.Header("Content-Type", "text/csv")
	c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=stats-%s-%s.csv", repo.Name, time.Now().Format("20060102")))

	c.Write([]byte("Author,Email,Total Effective Lines,Top Language\n"))

	for _, author := range statsData.Authors {
		topLang := ""
		maxLines := 0
		for lang, count := range author.FileTypes {
			if count > maxLines {
				maxLines = count
				topLang = lang
			}
		}
		line := fmt.Sprintf("%s,%s,%d,%s\n", author.Name, author.Email, author.TotalLines, topLang)
		c.Write([]byte(line))
	}
}

// GetLineStats .
// @router /api/v1/stats/lines [GET]
func GetLineStats(ctx context.Context, c *app.RequestContext) {
	repoKey := c.Query("repo_key")
	if repoKey == "" {
		response.BadRequest(c, "repo_key is required")
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(repoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	// 解析排除配置
	excludeDirs := c.Query("exclude_dirs")
	excludePatterns := c.Query("exclude_patterns")

	// 解析筛选参数
	branch := c.Query("branch")
	author := c.Query("author")
	since := c.Query("since")
	until := c.Query("until")

	config := stats.CountConfig{
		ExcludeDirs:     stats.DefaultExcludeDirs,
		ExcludePatterns: stats.DefaultExcludePatterns,
		ExcludeHidden:   true,
		Branch:          branch,
		Author:          author,
		Since:           since,
		Until:           until,
	}

	if excludeDirs != "" {
		config.ExcludeDirs = append(config.ExcludeDirs, strings.Split(excludeDirs, ",")...)
	}
	if excludePatterns != "" {
		config.ExcludePatterns = append(config.ExcludePatterns, strings.Split(excludePatterns, ",")...)
	}

	lineCounter := stats.GetLineCounter()
	result := lineCounter.GetLineStats(repo.Path, config)

	if result.Status == "processing" {
		response.Accepted(c, "正在统计代码行数，请稍后重试", map[string]interface{}{
			"status":   result.Status,
			"progress": result.Progress,
		})
		return
	}

	response.Success(c, result)
}

// GetLineStatsConfig .
// @router /api/v1/stats/lines/config [GET]
func GetLineStatsConfig(ctx context.Context, c *app.RequestContext) {
	// 返回默认配置
	response.Success(c, api.LineStatsConfig{
		ExcludeDirs:     stats.DefaultExcludeDirs,
		ExcludePatterns: stats.DefaultExcludePatterns,
	})
}

// SaveLineStatsConfig .
// @router /api/v1/stats/lines/config [POST]
func SaveLineStatsConfig(ctx context.Context, c *app.RequestContext) {
	var req api.LineStatsConfigRequest
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	if req.RepoKey == "" {
		response.BadRequest(c, "repo_key is required")
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(req.RepoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	// 清除该仓库的缓存，以便下次统计使用新配置
	lineCounter := stats.GetLineCounter()
	lineCounter.ClearCache(repo.Path)

	response.Success(c, map[string]string{
		"message": "配置已保存，下次统计将使用新配置",
	})
}

// ExportLineStatsCSV .
// @router /api/v1/stats/lines/export/csv [GET]
func ExportLineStatsCSV(ctx context.Context, c *app.RequestContext) {
	repoKey := c.Query("repo_key")
	if repoKey == "" {
		c.JSON(consts.StatusBadRequest, map[string]string{"error": "repo_key is required"})
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(repoKey)
	if err != nil {
		c.JSON(consts.StatusNotFound, map[string]string{"error": "repo not found"})
		return
	}

	// 解析排除配置
	excludeDirs := c.Query("exclude_dirs")
	excludePatterns := c.Query("exclude_patterns")

	// 解析筛选参数
	branch := c.Query("branch")
	author := c.Query("author")
	since := c.Query("since")
	until := c.Query("until")

	config := stats.CountConfig{
		ExcludeDirs:     stats.DefaultExcludeDirs,
		ExcludePatterns: stats.DefaultExcludePatterns,
		ExcludeHidden:   true,
		Branch:          branch,
		Author:          author,
		Since:           since,
		Until:           until,
	}

	if excludeDirs != "" {
		config.ExcludeDirs = append(config.ExcludeDirs, strings.Split(excludeDirs, ",")...)
	}
	if excludePatterns != "" {
		config.ExcludePatterns = append(config.ExcludePatterns, strings.Split(excludePatterns, ",")...)
	}

	lineCounter := stats.GetLineCounter()
	result := lineCounter.GetLineStats(repo.Path, config)

	if result.Status == "processing" {
		response.Accepted(c, "正在统计代码行数，请稍后重试", nil)
		return
	}

	c.Header("Content-Type", "text/csv")
	c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=linestats-%s-%s.csv", repo.Name, time.Now().Format("20060102")))

	c.Write([]byte("Language,Files,Code,Comment,Blank,Total\n"))

	for _, lang := range result.Languages {
		total := lang.Code + lang.Comment + lang.Blank
		line := fmt.Sprintf("%s,%d,%d,%d,%d,%d\n", lang.Name, lang.Files, lang.Code, lang.Comment, lang.Blank, total)
		c.Write([]byte(line))
	}

	// 写入汇总行
	totalLine := fmt.Sprintf("Total,%d,%d,%d,%d,%d\n",
		result.TotalFiles, result.CodeLines, result.CommentLines, result.BlankLines, result.TotalLines)
	c.Write([]byte(totalLine))
}
