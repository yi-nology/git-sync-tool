// Code generated by hertz generator.

package system

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/yi-nology/git-manage-service/biz/dal/db"
	"github.com/yi-nology/git-manage-service/biz/model/api"
	systemModel "github.com/yi-nology/git-manage-service/biz/model/biz/system"
	"github.com/yi-nology/git-manage-service/biz/service/audit"
	"github.com/yi-nology/git-manage-service/biz/service/git"
	"github.com/yi-nology/git-manage-service/pkg/appinfo"
	"github.com/yi-nology/git-manage-service/pkg/configs"
	"github.com/yi-nology/git-manage-service/pkg/response"
)

// GetConfig .
// @router /api/v1/system/config [GET]
func GetConfig(ctx context.Context, c *app.RequestContext) {
	gitSvc := git.NewGitService()
	name, email, _ := gitSvc.GetGlobalGitUser()

	response.Success(c, map[string]interface{}{
		"debug_mode":   configs.DebugMode,
		"author_name":  name,
		"author_email": email,
	})
}

// UpdateConfig .
// @router /api/v1/system/config [POST]
func UpdateConfig(ctx context.Context, c *app.RequestContext) {
	var req systemModel.UpdateConfigRequest
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	configs.DebugMode = req.DebugMode

	gitSvc := git.NewGitService()
	if err := gitSvc.SetGlobalGitUser(req.AuthorName, req.AuthorEmail); err != nil {
		response.InternalServerError(c, "Failed to set git config: "+err.Error())
		return
	}

	response.Success(c, map[string]interface{}{
		"debug_mode":   configs.DebugMode,
		"author_name":  req.AuthorName,
		"author_email": req.AuthorEmail,
	})
}

// ListDirs .
// @router /api/v1/system/dirs [GET]
func ListDirs(ctx context.Context, c *app.RequestContext) {
	var req systemModel.ListDirsRequest
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	currentPath := req.Path
	if currentPath == "" {
		home, err := os.UserHomeDir()
		if err != nil {
			currentPath = "/"
		} else {
			currentPath = home
		}
	}

	entries, err := os.ReadDir(currentPath)
	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	var dirs []api.DirItem
	for _, entry := range entries {
		if entry.IsDir() && !strings.HasPrefix(entry.Name(), ".") {
			if req.Search != "" && !strings.Contains(strings.ToLower(entry.Name()), strings.ToLower(req.Search)) {
				continue
			}
			dirs = append(dirs, api.DirItem{
				Name: entry.Name(),
				Path: filepath.Join(currentPath, entry.Name()),
			})
		}
	}

	sort.Slice(dirs, func(i, j int) bool {
		return dirs[i].Name < dirs[j].Name
	})

	parent := filepath.Dir(currentPath)
	if currentPath == "/" {
		parent = ""
	}

	response.Success(c, api.ListDirsResp{
		Parent:  parent,
		Current: currentPath,
		Dirs:    dirs,
	})
}

// ListSSHKeys .
// @router /api/v1/system/ssh-keys [GET]
func ListSSHKeys(ctx context.Context, c *app.RequestContext) {
	home, err := os.UserHomeDir()
	if err != nil {
		response.InternalServerError(c, "cannot find home dir")
		return
	}

	sshDir := filepath.Join(home, ".ssh")
	entries, err := os.ReadDir(sshDir)
	if err != nil {
		response.Success(c, []api.SSHKey{})
		return
	}

	var keys []api.SSHKey
	for _, entry := range entries {
		if !entry.IsDir() {
			keys = append(keys, api.SSHKey{
				Name: entry.Name(),
				Path: filepath.Join(sshDir, entry.Name()),
			})
		}
	}

	response.Success(c, keys)
}

// TestConnection .
// @router /api/v1/system/test-connection [POST]
func TestConnection(ctx context.Context, c *app.RequestContext) {
	var req systemModel.TestConnectionRequest
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	gitSvc := git.NewGitService()
	if err := gitSvc.TestRemoteConnection(req.Url); err != nil {
		response.Success(c, map[string]string{"status": "failed", "error": err.Error()})
		return
	}

	response.Success(c, map[string]string{"status": "success"})
}

// GetRepoStatus .
// @router /api/v1/system/repo/status [GET]
func GetRepoStatus(ctx context.Context, c *app.RequestContext) {
	repoKey := c.Query("repo_key")
	if repoKey == "" {
		response.BadRequest(c, "repo_key is required")
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(repoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()
	status, err := gitSvc.GetStatus(repo.Path)
	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	response.Success(c, map[string]string{"status": status})
}

// GetRepoGitConfig .
// @router /api/v1/system/repo/git-config [GET]
func GetRepoGitConfig(ctx context.Context, c *app.RequestContext) {
	repoKey := c.Query("repo_key")
	if repoKey == "" {
		response.BadRequest(c, "repo_key is required")
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(repoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()
	name, email, _ := gitSvc.GetGitUser(repo.Path)

	response.Success(c, map[string]string{
		"name":  name,
		"email": email,
	})
}

// SubmitChanges .
// @router /api/v1/system/repo/submit [POST]
func SubmitChanges(ctx context.Context, c *app.RequestContext) {
	var req systemModel.SubmitChangesRequest
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	if req.Message == "" {
		response.BadRequest(c, "commit message is required")
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(req.RepoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()

	// Selective file staging or add all
	if len(req.Files) > 0 {
		if err := gitSvc.AddFiles(repo.Path, req.Files); err != nil {
			response.InternalServerError(c, "Failed to stage files: "+err.Error())
			return
		}
	} else {
		if err := gitSvc.AddAll(repo.Path); err != nil {
			response.InternalServerError(c, "Failed to stage files: "+err.Error())
			return
		}
	}

	status, _ := gitSvc.GetStatus(repo.Path)
	fullMsg := fmt.Sprintf("%s\n\nGit Status Snapshot:\n%s", req.Message, status)

	if err := gitSvc.Commit(repo.Path, fullMsg, req.AuthorName, req.AuthorEmail); err != nil {
		_ = gitSvc.Reset(repo.Path)
		response.InternalServerError(c, "Failed to commit: "+err.Error())
		return
	}

	msg := "Committed successfully"

	if req.Push {
		if err := gitSvc.PushCurrent(repo.Path); err != nil {
			msg += ", but push failed: " + err.Error()
			response.Success(c, map[string]string{"message": msg, "warning": "push_failed"})
			return
		}
		msg += " and pushed to remote"
	}

	audit.AuditSvc.Log(c, "SUBMIT_CHANGES", "repo:"+repo.Key, map[string]interface{}{
		"message": req.Message,
		"push":    req.Push,
		"files":   req.Files,
	})

	response.Success(c, map[string]string{"message": msg})
}

// GetAppInfo 获取应用版本信息
// @router /api/v1/system/app-info [GET]
func GetAppInfo(ctx context.Context, c *app.RequestContext) {
	response.Success(c, map[string]string{
		"app_name":   appinfo.AppName,
		"version":    appinfo.Version,
		"build_time": appinfo.BuildTime,
		"git_commit": appinfo.GitCommit,
	})
}
