// Code generated by hertz generator.

package repo

import (
	"context"
	"os"
	"path/filepath"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/google/uuid"
	"github.com/yi-nology/git-manage-service/biz/dal/db"
	"github.com/yi-nology/git-manage-service/biz/model/api"
	"github.com/yi-nology/git-manage-service/biz/model/po"
	"github.com/yi-nology/git-manage-service/biz/service/audit"
	"github.com/yi-nology/git-manage-service/biz/service/git"
	"github.com/yi-nology/git-manage-service/biz/service/stats"
	"github.com/yi-nology/git-manage-service/pkg/response"
)

// List .
// @router /api/v1/repo/list [GET]
func List(ctx context.Context, c *app.RequestContext) {
	repos, err := db.NewRepoDAO().FindAll()
	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}
	var dtos []api.RepoDTO
	for _, r := range repos {
		dtos = append(dtos, api.NewRepoDTO(r))
	}
	response.Success(c, dtos)
}

// Get .
// @router /api/v1/repo/detail [GET]
func Get(ctx context.Context, c *app.RequestContext) {
	key := c.Query("key")
	if key == "" {
		response.BadRequest(c, "key is required")
		return
	}
	repo, err := db.NewRepoDAO().FindByKey(key)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}
	response.Success(c, api.NewRepoDTO(*repo))
}

// Create .
// @router /api/v1/repo/create [POST]
func Create(ctx context.Context, c *app.RequestContext) {
	var req api.RegisterRepoReq
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	// Validate path
	gitSvc := git.NewGitService()
	if !gitSvc.IsGitRepo(req.Path) {
		response.BadRequest(c, "path is not a valid git repository")
		return
	}

	// Sync Remotes if provided
	if len(req.Remotes) > 0 {
		existingConfig, err := gitSvc.GetRepoConfig(req.Path)
		if err == nil {
			for _, existing := range existingConfig.Remotes {
				found := false
				for _, r := range req.Remotes {
					if r.Name == existing.Name {
						found = true
						break
					}
				}
				if !found {
					gitSvc.RemoveRemote(req.Path, existing.Name)
				}
			}

			for _, r := range req.Remotes {
				gitSvc.RemoveRemote(req.Path, r.Name)
				if err := gitSvc.AddRemote(req.Path, r.Name, r.FetchURL, r.IsMirror); err != nil {
					// log error but continue
				}
				if r.PushURL != "" && r.PushURL != r.FetchURL {
					gitSvc.SetRemotePushURL(req.Path, r.Name, r.PushURL)
				}
			}
		}
	}

	repo := po.Repo{
		Key:          uuid.New().String(),
		Name:         req.Name,
		Path:         req.Path,
		RemoteURL:    req.RemoteURL,
		AuthType:     req.AuthType,
		AuthKey:      req.AuthKey,
		AuthSecret:   req.AuthSecret,
		ConfigSource: req.ConfigSource,
		RemoteAuths:  req.RemoteAuths,
	}
	if repo.ConfigSource == "" {
		repo.ConfigSource = "local"
	}
	if err := db.NewRepoDAO().Create(&repo); err != nil {
		response.InternalServerError(c, err.Error())
		return
	}
	audit.AuditSvc.Log(c, "CREATE", "repo:"+repo.Key, map[string]string{"name": repo.Name, "path": repo.Path})

	// Trigger async stats sync
	go func() {
		head, err := gitSvc.GetHeadBranch(repo.Path)
		if err == nil && head != "" {
			stats.StatsSvc.SyncRepoStats(repo.ID, repo.Path, head)
		}
	}()

	response.Success(c, api.NewRepoDTO(repo))
}

// Update .
// @router /api/v1/repo/update [POST]
func Update(ctx context.Context, c *app.RequestContext) {
	var req struct {
		Key string `json:"key"`
		api.RegisterRepoReq
	}
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	repoDAO := db.NewRepoDAO()
	repo, err := repoDAO.FindByKey(req.Key)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	// Validate path if changed
	if req.Path != repo.Path {
		gitSvc := git.NewGitService()
		if !gitSvc.IsGitRepo(req.Path) {
			response.BadRequest(c, "path is not a valid git repository")
			return
		}
	}

	// Sync Remotes if provided
	if len(req.Remotes) > 0 {
		gitSvc := git.NewGitService()
		existingConfig, err := gitSvc.GetRepoConfig(req.Path)
		if err == nil {
			for _, existing := range existingConfig.Remotes {
				found := false
				for _, r := range req.Remotes {
					if r.Name == existing.Name {
						found = true
						break
					}
				}
				if !found {
					gitSvc.RemoveRemote(req.Path, existing.Name)
				}
			}

			for _, r := range req.Remotes {
				gitSvc.RemoveRemote(req.Path, r.Name)
				if err := gitSvc.AddRemote(req.Path, r.Name, r.FetchURL, r.IsMirror); err != nil {
					// log error but continue
				}
				if r.PushURL != "" && r.PushURL != r.FetchURL {
					gitSvc.SetRemotePushURL(req.Path, r.Name, r.PushURL)
				}
			}
		}
	}

	repo.Name = req.Name
	repo.Path = req.Path
	repo.RemoteURL = req.RemoteURL
	repo.AuthType = req.AuthType
	repo.AuthKey = req.AuthKey
	repo.AuthSecret = req.AuthSecret
	repo.ConfigSource = req.ConfigSource
	repo.RemoteAuths = req.RemoteAuths
	if repo.ConfigSource == "" {
		repo.ConfigSource = "local"
	}

	if err := repoDAO.Save(repo); err != nil {
		response.InternalServerError(c, err.Error())
		return
	}
	audit.AuditSvc.Log(c, "UPDATE", "repo:"+repo.Key, map[string]string{"name": repo.Name})
	response.Success(c, api.NewRepoDTO(*repo))
}

// Delete .
// @router /api/v1/repo/delete [POST]
func Delete(ctx context.Context, c *app.RequestContext) {
	var req struct {
		Key string `json:"key"`
	}
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	repoDAO := db.NewRepoDAO()
	repo, err := repoDAO.FindByKey(req.Key)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	// Check if used in SyncTask
	count, _ := db.NewSyncTaskDAO().CountByRepoKey(repo.Key)
	if count > 0 {
		response.BadRequest(c, "cannot delete repo used in sync tasks")
		return
	}

	if err := repoDAO.Delete(repo); err != nil {
		response.InternalServerError(c, err.Error())
		return
	}
	audit.AuditSvc.Log(c, "DELETE", "repo:"+repo.Key, nil)
	response.Success(c, map[string]string{"message": "deleted"})
}

// Scan .
// @router /api/v1/repo/scan [POST]
func Scan(ctx context.Context, c *app.RequestContext) {
	var req api.ScanRepoReq
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	gitSvc := git.NewGitService()
	if !gitSvc.IsGitRepo(req.Path) {
		response.BadRequest(c, "path is not a valid git repository")
		return
	}

	config, err := gitSvc.GetRepoConfig(req.Path)
	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	response.Success(c, config)
}

// Clone .
// @router /api/v1/repo/clone [POST]
func Clone(ctx context.Context, c *app.RequestContext) {
	var req api.CloneRepoReq
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	gitSvc := git.NewGitService()
	if _, err := os.Stat(req.LocalPath); err == nil {
		if gitSvc.IsGitRepo(req.LocalPath) {
			response.BadRequest(c, "directory already contains a git repository")
			return
		}
	}

	taskID := uuid.New().String()
	git.GlobalTaskManager.AddTask(taskID)

	go func() {
		progressChan := make(chan string)

		go func() {
			for msg := range progressChan {
				git.GlobalTaskManager.AppendLog(taskID, msg)
			}
		}()

		err := gitSvc.CloneWithProgress(req.RemoteURL, req.LocalPath, req.AuthType, req.AuthKey, req.AuthSecret, progressChan)
		close(progressChan)

		if err != nil {
			git.GlobalTaskManager.UpdateStatus(taskID, "failed", err.Error())
			return
		}

		git.GlobalTaskManager.UpdateStatus(taskID, "success", "")

		name := filepath.Base(req.LocalPath)
		repo := po.Repo{
			Key:          uuid.New().String(),
			Name:         name,
			Path:         req.LocalPath,
			RemoteURL:    req.RemoteURL,
			AuthType:     req.AuthType,
			AuthKey:      req.AuthKey,
			AuthSecret:   req.AuthSecret,
			ConfigSource: req.ConfigSource,
		}
		if repo.ConfigSource == "" {
			repo.ConfigSource = "local"
		}
		db.NewRepoDAO().Create(&repo)

		go func() {
			head, err := gitSvc.GetHeadBranch(repo.Path)
			if err == nil && head != "" {
				stats.StatsSvc.SyncRepoStats(repo.ID, repo.Path, head)
			}
		}()
	}()

	response.Success(c, map[string]string{"task_id": taskID})
}

// Fetch .
// @router /api/v1/repo/fetch [POST]
func Fetch(ctx context.Context, c *app.RequestContext) {
	var req struct {
		RepoKey string `json:"repo_key"`
	}
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(req.RepoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()
	if err := gitSvc.FetchAll(repo.Path); err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	audit.AuditSvc.Log(c, "FETCH_REPO", "repo:"+repo.Key, nil)
	response.Success(c, map[string]string{"message": "fetched"})
}

// GetCloneTask .
// @router /api/v1/repo/task [GET]
func GetCloneTask(ctx context.Context, c *app.RequestContext) {
	id := c.Query("task_id")
	if id == "" {
		response.BadRequest(c, "task_id is required")
		return
	}
	task, ok := git.GlobalTaskManager.GetTask(id)
	if !ok {
		response.NotFound(c, "task not found")
		return
	}
	response.Success(c, task)
}
