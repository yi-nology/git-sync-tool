// Code generated by hertz generator.

package sync

import (
	"context"
	"strconv"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/google/uuid"
	"github.com/yi-nology/git-manage-service/biz/dal/db"
	"github.com/yi-nology/git-manage-service/biz/model/api"
	syncModel "github.com/yi-nology/git-manage-service/biz/model/biz/sync"
	"github.com/yi-nology/git-manage-service/biz/model/po"
	"github.com/yi-nology/git-manage-service/biz/service/audit"
	syncSvc "github.com/yi-nology/git-manage-service/biz/service/sync"
	"github.com/yi-nology/git-manage-service/pkg/response"
)

// ListTasks .
// @router /api/v1/sync/tasks [GET]
func ListTasks(ctx context.Context, c *app.RequestContext) {
	var req syncModel.ListTasksRequest
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	var tasks []po.SyncTask
	var err error

	taskDAO := db.NewSyncTaskDAO()

	if req.RepoKey != "" {
		tasks, err = taskDAO.FindByRepoKey(req.RepoKey)
	} else {
		tasks, err = taskDAO.FindAllWithRepos()
	}

	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}
	var dtos []api.SyncTaskDTO
	for _, t := range tasks {
		dtos = append(dtos, api.NewSyncTaskDTO(t))
	}
	response.Success(c, dtos)
}

// GetTask .
// @router /api/v1/sync/task [GET]
func GetTask(ctx context.Context, c *app.RequestContext) {
	var req syncModel.GetTaskRequest
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	if req.Key == "" {
		response.BadRequest(c, "key is required")
		return
	}

	task, err := db.NewSyncTaskDAO().FindByKey(req.Key)
	if err != nil {
		response.NotFound(c, "task not found")
		return
	}
	response.Success(c, api.NewSyncTaskDTO(*task))
}

// CreateTask .
// @router /api/v1/sync/task/create [POST]
func CreateTask(ctx context.Context, c *app.RequestContext) {
	var req syncModel.CreateTaskRequest
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	task := po.SyncTask{
		Key:           uuid.New().String(),
		SourceRepoKey: req.SourceRepoKey,
		SourceRemote:  req.SourceRemote,
		SourceBranch:  req.SourceBranch,
		TargetRepoKey: req.TargetRepoKey,
		TargetRemote:  req.TargetRemote,
		TargetBranch:  req.TargetBranch,
		PushOptions:   req.PushOptions,
		Cron:          req.Cron,
		Enabled:       req.Enabled,
	}

	if err := db.NewSyncTaskDAO().Create(&task); err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	syncSvc.CronSvc.UpdateTask(task)
	audit.AuditSvc.Log(c, "CREATE", "task:"+task.Key, task)
	response.Success(c, api.NewSyncTaskDTO(task))
}

// UpdateTask .
// @router /api/v1/sync/task/update [POST]
func UpdateTask(ctx context.Context, c *app.RequestContext) {
	var req syncModel.UpdateTaskRequest
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	taskDAO := db.NewSyncTaskDAO()
	task, err := taskDAO.FindByKey(req.Key)
	if err != nil {
		response.NotFound(c, "task not found")
		return
	}

	task.SourceRepoKey = req.SourceRepoKey
	task.SourceRemote = req.SourceRemote
	task.SourceBranch = req.SourceBranch
	task.TargetRepoKey = req.TargetRepoKey
	task.TargetRemote = req.TargetRemote
	task.TargetBranch = req.TargetBranch
	task.PushOptions = req.PushOptions
	task.Cron = req.Cron
	task.Enabled = req.Enabled

	if err := taskDAO.Save(task); err != nil {
		response.InternalServerError(c, err.Error())
		return
	}
	syncSvc.CronSvc.UpdateTask(*task)
	audit.AuditSvc.Log(c, "UPDATE", "task:"+task.Key, task)

	response.Success(c, api.NewSyncTaskDTO(*task))
}

// DeleteTask .
// @router /api/v1/sync/task/delete [POST]
func DeleteTask(ctx context.Context, c *app.RequestContext) {
	var req syncModel.DeleteTaskRequest
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	taskDAO := db.NewSyncTaskDAO()
	task, err := taskDAO.FindByKey(req.Key)
	if err != nil {
		response.NotFound(c, "task not found")
		return
	}

	taskDAO.Delete(task)
	syncSvc.CronSvc.RemoveTask(task.ID)
	audit.AuditSvc.Log(c, "DELETE", "task:"+task.Key, nil)

	response.Success(c, map[string]string{"message": "deleted"})
}

// RunTask .
// @router /api/v1/sync/run [POST]
func RunTask(ctx context.Context, c *app.RequestContext) {
	var req syncModel.RunTaskRequest
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	go func() {
		svc := syncSvc.NewSyncService()
		svc.RunTask(req.TaskKey)
	}()

	audit.AuditSvc.Log(c, "SYNC", "task_key:"+req.TaskKey, nil)
	response.Success(c, map[string]string{"status": "started"})
}

// ExecuteSync .
// @router /api/v1/sync/execute [POST]
func ExecuteSync(ctx context.Context, c *app.RequestContext) {
	var req syncModel.ExecuteSyncRequest
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(req.RepoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	task := po.SyncTask{
		Key:           uuid.New().String(),
		SourceRepoKey: repo.Key,
		SourceRepo:    *repo,
		SourceRemote:  req.SourceRemote,
		SourceBranch:  req.SourceBranch,
		TargetRepoKey: repo.Key,
		TargetRepo:    *repo,
		TargetRemote:  req.TargetRemote,
		TargetBranch:  req.TargetBranch,
		PushOptions:   req.PushOptions,
	}

	go func() {
		svc := syncSvc.NewSyncService()
		svc.ExecuteSync(&task)
	}()

	audit.AuditSvc.Log(c, "SYNC_ADHOC", "task:"+task.Key, task)
	response.Success(c, map[string]string{"status": "started", "task_key": task.Key})
}

// ListHistory .
// @router /api/v1/sync/history [GET]
func ListHistory(ctx context.Context, c *app.RequestContext) {
	var req syncModel.ListHistoryRequest
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	limit := int(req.Limit)
	if limit < 1 {
		limit = 50
	}

	var runs []po.SyncRun
	var err error

	runDAO := db.NewSyncRunDAO()

	if req.TaskKey != "" {
		runs, err = runDAO.FindByTaskKeys([]string{req.TaskKey}, limit)
	} else if req.RepoKey != "" {
		taskKeys, _ := db.NewSyncTaskDAO().GetKeysByRepoKey(req.RepoKey)

		if len(taskKeys) > 0 {
			runs, err = runDAO.FindByTaskKeys(taskKeys, limit)
		} else {
			response.Success(c, []api.SyncRunDTO{})
			return
		}
	} else {
		runs, err = runDAO.FindLatest(limit)
	}

	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}
	var dtos []api.SyncRunDTO
	for _, r := range runs {
		dtos = append(dtos, api.NewSyncRunDTO(r))
	}
	response.Success(c, dtos)
}

// DeleteHistory .
// @router /api/v1/sync/history/delete [POST]
func DeleteHistory(ctx context.Context, c *app.RequestContext) {
	var req syncModel.DeleteHistoryRequest
	if err := c.BindAndValidate(&req); err != nil {
		// Also try query param for backwards compatibility
		idStr := c.Query("id")
		if idStr != "" {
			id, _ := strconv.Atoi(idStr)
			req.Id = int64(id)
		} else {
			response.BadRequest(c, err.Error())
			return
		}
	}

	if err := db.NewSyncRunDAO().Delete(uint(req.Id)); err != nil {
		response.InternalServerError(c, err.Error())
		return
	}
	response.Success(c, map[string]string{"message": "deleted"})
}
