// Code generated by hertz generator.

package branch

import (
	"context"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/google/uuid"
	"github.com/yi-nology/git-manage-service/biz/dal/db"
	"github.com/yi-nology/git-manage-service/biz/model/api"
	"github.com/yi-nology/git-manage-service/biz/model/domain"
	"github.com/yi-nology/git-manage-service/biz/service/audit"
	"github.com/yi-nology/git-manage-service/biz/service/git"
	"github.com/yi-nology/git-manage-service/pkg/response"
)

// List .
// @router /api/v1/branch/list [GET]
func List(ctx context.Context, c *app.RequestContext) {
	repoKey := c.Query("repo_key")
	if repoKey == "" {
		response.BadRequest(c, "repo_key is required")
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(repoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()
	branches, err := gitSvc.ListBranchesWithInfo(repo.Path)
	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	// Filter
	keyword := c.Query("keyword")
	if keyword != "" {
		var filtered []domain.BranchInfo
		keyword = strings.ToLower(keyword)
		for _, b := range branches {
			if strings.Contains(strings.ToLower(b.Name), keyword) ||
				strings.Contains(strings.ToLower(b.Author), keyword) {
				filtered = append(filtered, b)
			}
		}
		branches = filtered
	}

	// Pagination
	page, _ := strconv.Atoi(c.Query("page"))
	if page < 1 {
		page = 1
	}
	pageSize, _ := strconv.Atoi(c.Query("page_size"))
	if pageSize < 1 {
		pageSize = 100
	}

	start := (page - 1) * pageSize
	end := start + pageSize
	if start > len(branches) {
		start = len(branches)
	}
	if end > len(branches) {
		end = len(branches)
	}

	paged := branches[start:end]

	for i := range paged {
		b := &paged[i]
		if b.Upstream != "" {
			ahead, behind, _ := gitSvc.GetBranchSyncStatus(repo.Path, b.Name, b.Upstream)
			b.Ahead = ahead
			b.Behind = behind
		}
	}

	response.Success(c, map[string]interface{}{
		"total": len(branches),
		"list":  paged,
	})
}

// Create .
// @router /api/v1/branch/create [POST]
func Create(ctx context.Context, c *app.RequestContext) {
	var req struct {
		RepoKey string `json:"repo_key"`
		Name    string `json:"name"`
		BaseRef string `json:"base_ref"`
	}
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(req.RepoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()
	if err := gitSvc.CreateBranch(repo.Path, req.Name, req.BaseRef); err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	audit.AuditSvc.Log(c, "CREATE_BRANCH", "repo:"+repo.Key, map[string]string{
		"branch": req.Name,
		"base":   req.BaseRef,
	})
	response.Success(c, map[string]string{"message": "created"})
}

// Delete .
// @router /api/v1/branch/delete [POST]
func Delete(ctx context.Context, c *app.RequestContext) {
	var req struct {
		RepoKey string `json:"repo_key"`
		Name    string `json:"name"`
		Force   bool   `json:"force"`
	}
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(req.RepoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()
	if err := gitSvc.DeleteBranch(repo.Path, req.Name, req.Force); err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	audit.AuditSvc.Log(c, "DELETE_BRANCH", "repo:"+repo.Key, map[string]string{
		"branch": req.Name,
		"force":  strconv.FormatBool(req.Force),
	})
	response.Success(c, map[string]string{"message": "deleted"})
}

// Update .
// @router /api/v1/branch/update [POST]
func Update(ctx context.Context, c *app.RequestContext) {
	var req struct {
		RepoKey string `json:"repo_key"`
		Name    string `json:"name"`
		NewName string `json:"new_name"`
		Desc    string `json:"desc"`
	}
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(req.RepoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()
	currentName := req.Name

	// Rename
	if req.NewName != "" && req.NewName != currentName {
		if err := gitSvc.RenameBranch(repo.Path, currentName, req.NewName); err != nil {
			response.InternalServerError(c, err.Error())
			return
		}
		currentName = req.NewName
	}

	// Description
	if req.Desc != "" {
		if err := gitSvc.SetBranchDescription(repo.Path, currentName, req.Desc); err != nil {
			// Log but don't fail
		}
	}

	audit.AuditSvc.Log(c, "UPDATE_BRANCH", "repo:"+repo.Key, map[string]string{
		"old_name": req.Name,
		"new_name": req.NewName,
		"desc":     req.Desc,
	})
	response.Success(c, map[string]string{"message": "updated"})
}

// Checkout .
// @router /api/v1/branch/checkout [POST]
func Checkout(ctx context.Context, c *app.RequestContext) {
	var req struct {
		RepoKey string `json:"repo_key"`
		Name    string `json:"name"`
	}
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(req.RepoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()
	if err := gitSvc.CheckoutBranch(repo.Path, req.Name); err != nil {
		response.BadRequest(c, "Checkout failed: "+err.Error())
		return
	}

	audit.AuditSvc.Log(c, "CHECKOUT_BRANCH", "repo:"+repo.Key, map[string]string{
		"branch": req.Name,
	})
	response.Success(c, map[string]string{"message": "checked out " + req.Name})
}

// Push .
// @router /api/v1/branch/push [POST]
func Push(ctx context.Context, c *app.RequestContext) {
	var req struct {
		RepoKey string   `json:"repo_key"`
		Name    string   `json:"name"`
		Remotes []string `json:"remotes"`
	}
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(req.RepoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()

	var errors []string
	for _, remote := range req.Remotes {
		if err := gitSvc.PushBranch(repo.Path, remote, req.Name); err != nil {
			errors = append(errors, fmt.Sprintf("%s: %v", remote, err))
		}
	}

	if len(errors) > 0 {
		response.InternalServerError(c, strings.Join(errors, "; "))
		return
	}

	audit.AuditSvc.Log(c, "PUSH_BRANCH", "repo:"+repo.Key, map[string]interface{}{
		"branch":  req.Name,
		"remotes": req.Remotes,
	})
	response.Success(c, map[string]string{"message": "pushed"})
}

// Pull .
// @router /api/v1/branch/pull [POST]
func Pull(ctx context.Context, c *app.RequestContext) {
	var req struct {
		RepoKey string `json:"repo_key"`
		Name    string `json:"name"`
	}
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(req.RepoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()
	branches, _ := gitSvc.ListBranchesWithInfo(repo.Path)

	var isCurrent bool
	var upstreamRemote string
	var remoteBranch string

	for _, b := range branches {
		if b.Name == req.Name {
			isCurrent = b.IsCurrent
			if b.Upstream != "" {
				parts := strings.Split(b.Upstream, "/")
				if len(parts) > 0 {
					upstreamRemote = parts[0]
					if len(parts) > 1 {
						remoteBranch = strings.Join(parts[1:], "/")
					}
				}
			}
			break
		}
	}

	if upstreamRemote == "" {
		response.BadRequest(c, "No upstream configured for this branch")
		return
	}

	if remoteBranch == "" {
		remoteBranch = req.Name
	}

	if !isCurrent {
		if err := gitSvc.UpdateBranchFastForward(repo.Path, upstreamRemote, req.Name, remoteBranch); err != nil {
			response.InternalServerError(c, fmt.Sprintf("Update failed (must be fast-forward): %v", err))
			return
		}

		audit.AuditSvc.Log(c, "UPDATE_BRANCH", "repo:"+repo.Key, map[string]string{
			"branch": req.Name,
			"remote": upstreamRemote,
			"type":   "fast-forward",
		})
		response.Success(c, map[string]string{"message": "updated (fast-forward)"})
		return
	}

	if err := gitSvc.PullBranch(repo.Path, upstreamRemote, req.Name); err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	audit.AuditSvc.Log(c, "PULL_BRANCH", "repo:"+repo.Key, map[string]string{
		"branch": req.Name,
		"remote": upstreamRemote,
	})
	response.Success(c, map[string]string{"message": "synced"})
}

// Compare .
// @router /api/v1/branch/compare [GET]
func Compare(ctx context.Context, c *app.RequestContext) {
	repoKey := c.Query("repo_key")
	base := c.Query("base")
	target := c.Query("target")

	if base == "" || target == "" {
		response.BadRequest(c, "base and target branches are required")
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(repoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()

	stat, err := gitSvc.GetDiffStat(repo.Path, base, target)
	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	files, err := gitSvc.GetDiffFiles(repo.Path, base, target)
	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	response.Success(c, map[string]interface{}{
		"stat":  stat,
		"files": files,
	})
}

// GetDiff .
// @router /api/v1/branch/diff [GET]
func GetDiff(ctx context.Context, c *app.RequestContext) {
	repoKey := c.Query("repo_key")
	base := c.Query("base")
	target := c.Query("target")
	file := c.Query("file")

	repo, err := db.NewRepoDAO().FindByKey(repoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()
	content, err := gitSvc.GetRawDiff(repo.Path, base, target, file)
	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	response.Success(c, map[string]string{"diff": content})
}

// MergeCheck .
// @router /api/v1/branch/merge/check [GET]
func MergeCheck(ctx context.Context, c *app.RequestContext) {
	repoKey := c.Query("repo_key")
	base := c.Query("base")
	target := c.Query("target")

	repo, err := db.NewRepoDAO().FindByKey(repoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()
	result, err := gitSvc.MergeDryRun(repo.Path, base, target)
	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	response.Success(c, result)
}

// Merge .
// @router /api/v1/branch/merge [POST]
func Merge(ctx context.Context, c *app.RequestContext) {
	var req struct {
		RepoKey string `json:"repo_key"`
		api.MergeReq
	}
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(req.RepoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()

	check, err := gitSvc.MergeDryRun(repo.Path, req.Source, req.Target)
	if err != nil {
		response.InternalServerError(c, "Pre-merge check failed: "+err.Error())
		return
	}
	if !check.Success {
		mergeID := uuid.New().String()
		reportURL := fmt.Sprintf("/merge_report.html?repo_key=%s&source=%s&target=%s&merge_id=%s", repo.Key, req.Source, req.Target, mergeID)

		audit.AuditSvc.Log(c, "MERGE_CONFLICT", "repo:"+repo.Key, map[string]interface{}{
			"source":    req.Source,
			"target":    req.Target,
			"conflicts": check.Conflicts,
			"merge_id":  mergeID,
		})

		c.JSON(200, response.Response{
			Code: 409,
			Msg:  "Merge conflict detected",
			Data: map[string]interface{}{
				"conflicts":  check.Conflicts,
				"report_url": reportURL,
				"merge_id":   mergeID,
			},
		})
		return
	}

	if err := gitSvc.Merge(repo.Path, req.Source, req.Target, req.Message); err != nil {
		response.InternalServerError(c, "Merge execution failed: "+err.Error())
		return
	}

	audit.AuditSvc.Log(c, "MERGE_SUCCESS", "repo:"+repo.Key, map[string]string{
		"source": req.Source,
		"target": req.Target,
	})

	response.Success(c, map[string]string{"status": "merged"})
}

// GetPatch .
// @router /api/v1/branch/patch [GET]
func GetPatch(ctx context.Context, c *app.RequestContext) {
	repoKey := c.Query("repo_key")
	base := c.Query("base")
	target := c.Query("target")

	repo, err := db.NewRepoDAO().FindByKey(repoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	gitSvc := git.NewGitService()
	patch, err := gitSvc.GetPatch(repo.Path, base, target)
	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	c.Header("Content-Type", "application/octet-stream")
	c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=%s-%s-%s.patch", repo.Name, base, time.Now().Format("20060102")))
	c.Write([]byte(patch))
}
