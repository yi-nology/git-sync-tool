// Code generated by hertz generator.

package tag

import (
	"context"
	"strconv"
	"strings"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/yi-nology/git-manage-service/biz/dal/db"
	"github.com/yi-nology/git-manage-service/biz/service/git"
	"github.com/yi-nology/git-manage-service/pkg/response"
)

// List .
// @router /api/v1/tag/list [GET]
func List(ctx context.Context, c *app.RequestContext) {
	repoKey := c.Query("repo_key")
	if repoKey == "" {
		response.BadRequest(c, "repo_key is required")
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(repoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	svc := git.NewGitService()
	tags, err := svc.GetTags(repo.Path)
	if err != nil {
		response.InternalServerError(c, err.Error())
		return
	}

	response.Success(c, tags)
}

// Create .
// @router /api/v1/tag/create [POST]
func Create(ctx context.Context, c *app.RequestContext) {
	var req struct {
		RepoKey    string `json:"repo_key"`
		TagName    string `json:"tag_name"`
		Ref        string `json:"ref"`
		Message    string `json:"message"`
		PushRemote string `json:"push_remote"`
	}
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	repo, err := db.NewRepoDAO().FindByKey(req.RepoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	svc := git.NewGitService()
	authorName, authorEmail, _ := svc.GetGlobalGitUser()

	tagName := req.TagName
	// Auto-increment version logic
	if tagName == "auto" {
		latest, err := svc.GetLatestVersion(repo.Path)
		if err != nil || latest == "" {
			tagName = "v0.1.0"
		} else {
			tagName = incrementVersion(latest)
		}
	}

	err = svc.CreateTag(repo.Path, tagName, req.Ref, req.Message, authorName, authorEmail)
	if err != nil {
		response.InternalServerError(c, "failed to create tag: "+err.Error())
		return
	}

	if req.PushRemote != "" {
		err = svc.PushTag(repo.Path, req.PushRemote, tagName, "none", "", "")
		if err != nil {
			response.Success(c, map[string]string{
				"status": "created_local_only",
				"error":  "tag created but push failed: " + err.Error(),
			})
			return
		}
	}

	response.Success(c, nil)
}

// Delete .
// @router /api/v1/tag/delete [POST]
func Delete(ctx context.Context, c *app.RequestContext) {
	var req struct {
		RepoKey string `json:"repo_key"`
		TagName string `json:"tag_name"`
	}
	if err := c.BindAndValidate(&req); err != nil {
		response.BadRequest(c, err.Error())
		return
	}

	_, err := db.NewRepoDAO().FindByKey(req.RepoKey)
	if err != nil {
		response.NotFound(c, "repo not found")
		return
	}

	// Note: DeleteTag not implemented in git service yet
	response.BadRequest(c, "tag deletion not supported")
}

func incrementVersion(v string) string {
	hasV := false
	if len(v) > 0 && v[0] == 'v' {
		hasV = true
		v = v[1:]
	}

	parts := strings.Split(v, ".")
	if len(parts) > 0 {
		lastIdx := len(parts) - 1
		lastNum, err := strconv.Atoi(parts[lastIdx])
		if err == nil {
			parts[lastIdx] = strconv.Itoa(lastNum + 1)
		} else {
			parts = append(parts, "1")
		}
	} else {
		return "v0.0.1"
	}

	res := strings.Join(parts, ".")
	if hasV {
		return "v" + res
	}
	return res
}
